(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{179:function(e,t,a){"use strict";a.r(t);var s=a(0),v=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vue-面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-面试题","aria-hidden":"true"}},[e._v("#")]),e._v(" vue 面试题")]),e._v(" "),a("h2",{attrs:{id:"vue的双向绑定的原理是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue的双向绑定的原理是什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" vue的双向绑定的原理是什么？")]),e._v(" "),a("ul",[a("li",[e._v("vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。")]),e._v(" "),a("li",[e._v("具体流程")]),e._v(" "),a("li",[e._v("1、observer 会监听所有的data变化")]),e._v(" "),a("li",[e._v("2、Dep 列表订阅了很多Watcher(涉及到响应式,包括页面渲染),")]),e._v(" "),a("li",[e._v("3、数据变化 触发observer 里面的set,他会通知dep 循环遍历watcher执行update 进行数据页面更新")])]),e._v(" "),a("h2",{attrs:{id:"vue中计算属性computer和普通属性method的区别是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中计算属性computer和普通属性method的区别是什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" vue中计算属性computer和普通属性method的区别是什么？")]),e._v(" "),a("ul",[a("li",[e._v("computed是响应式的，methods并非响应式。")]),e._v(" "),a("li",[e._v("调用方式不一样，computed的定义成员像属性一样访问，methods定义的成员必须以函数形式调用")]),e._v(" "),a("li",[e._v("computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，而methods里的函数在每次调用时都要执行。")]),e._v(" "),a("li",[e._v("computed不支持异步，当computed内有异步操作时无效，无法监听数据的变化")]),e._v(" "),a("li",[e._v("computed中的成员可以只定义一个函数作为只读属性，也可以定义get/set变成可读写属性，这点是methods中的成员做不到的")])]),e._v(" "),a("h2",{attrs:{id:"vue-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router","aria-hidden":"true"}},[e._v("#")]),e._v(" vue-router")]),e._v(" "),a("h3",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash","aria-hidden":"true"}},[e._v("#")]),e._v(" hash")]),e._v(" "),a("ul",[a("li",[e._v("1、hash模式 默认是hash模式，基于浏览器history api，使用window.addEventListener('hashchange',callback,false)对浏览器地址进行监听。")]),e._v(" "),a("li",[e._v("2、当调用push时，把新路由添加到浏览器访问历史的栈顶。")]),e._v(" "),a("li",[e._v("3、使用replace时，把浏览器访问历史的栈顶路由替换成新路由 hash的值等于url中#及其以后的内容。")]),e._v(" "),a("li",[e._v("4、浏览器是根据hash值的变化，将页面加载到相应的DOM位置。锚点变化只是浏览器的行为，每次锚点变化后依然会在浏览器中留下一条历史记录，可以通过浏览器的后退按钮回到上一个位置")])]),e._v(" "),a("h3",{attrs:{id:"history"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history","aria-hidden":"true"}},[e._v("#")]),e._v(" history")]),e._v(" "),a("ul",[a("li",[e._v("1、History history模式，基于浏览器history api ，使用window.onpopstate 对浏览器地址进行监听。")]),e._v(" "),a("li",[e._v("2、对浏览器history api中的pushState()、replaceState()进行封装，当方法调用，会对浏览器的历史栈进行修改。")]),e._v(" "),a("li",[e._v("3、从而实现URL的跳转而无需加载页面 但是他的问题在于当刷新页面的时候会走后端路由，所以需要服务端的辅助来兜底，避免URL无法匹配到资源时能返回页面")])]),e._v(" "),a("h3",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract","aria-hidden":"true"}},[e._v("#")]),e._v(" abstract")]),e._v(" "),a("ul",[a("li",[e._v("不涉及和浏览器地址的相关记录。流程跟hash模式一样，通过数组维护模拟浏览器的历史记录栈 服务端下使用。使用一个不依赖于浏览器的浏览器历史虚拟管理后台")])]),e._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("ul",[a("li",[e._v("hash模式和history模式都是通过window.addEvevtListenter()方法监听 hashchange和popState进行相应路由的操作。可以通过back、foward、go等方法访问浏览器的历史记录栈，进行各种跳转")]),e._v(" "),a("li",[e._v("而abstract模式是自己维护一个模拟的浏览器历史记录栈的数组")])]),e._v(" "),a("h2",{attrs:{id:"说一下vue的keep-alive是如何实现的，具体缓存的是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下vue的keep-alive是如何实现的，具体缓存的是什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 说一下Vue的keep-alive是如何实现的，具体缓存的是什么？")]),e._v(" "),a("ul",[a("li",[e._v("keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。")]),e._v(" "),a("li",[e._v("keep-alive 具体是通过cache数组缓存所有组件的vnode实例。当cache内原有组件被使用时会将该组件key从keys数组中删除，然后push到keys数组最后面，方便清除最不常用组件")])]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*\n  步骤总结\n  1.获取keep-alive下第一个子组件的实例对象，通过它去获取这个组件的名字\n  2.通过当前组件名去匹配原来include和exclude，判断当前组件是否需要缓存，不需要缓存直接返回当前组件的实例vnode\n  3.需要缓存，判断它当前是否在缓存数组里面，存在的话就将它原来的位置上的key给移除，同时将这个组件的key放到数组最后面\n  4.不存在的话，将组件key放入数组，然后判断当前key数组是否超过max所设置的范围，超过的话那就削减没使用时间最长的一个组件的key值\n  5.最后将这个组件的keepAlive设置为true\n  keep-alive本身的创建过程和patch过程\n  缓存渲染的时候，会根据vnode.componentInstance(首次渲染 vnode.componentInstance为undefined)和keepAlive属性判断不会执行组件的created、mounted等钩子函数，而是对缓存的组件执行patch过程：直接把缓存的DOM对象直接插入到目标元素中，完成了数据更新情况下的渲染过程\n*/")]),e._v("\n")])])]),a("h2",{attrs:{id:"在哪个生命周期内调用异步请求？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在哪个生命周期内调用异步请求？","aria-hidden":"true"}},[e._v("#")]),e._v(" 在哪个生命周期内调用异步请求？")]),e._v(" "),a("ul",[a("li",[e._v("可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是建议在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n"),a("ul",[a("li",[e._v("更快获取到服务端数据，减少页面 loading 时间")]),e._v(" "),a("li",[e._v("ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；")])])])]),e._v(" "),a("h2",{attrs:{id:"ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssr","aria-hidden":"true"}},[e._v("#")]),e._v(" ssr")]),e._v(" "),a("ul",[a("li",[e._v("页面的渲染在服务端完成，事件和交互的绑定在客户端完成")]),e._v(" "),a("li",[e._v("优点\n"),a("ul",[a("li",[e._v("更好的 SEO")]),e._v(" "),a("li",[e._v("首屏优化")])])]),e._v(" "),a("li",[e._v("缺点\n"),a("ul",[a("li",[e._v("开发的条件限制, 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数")]),e._v(" "),a("li",[e._v("更多的服务器负载")])])])]),e._v(" "),a("h2",{attrs:{id:"单向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流","aria-hidden":"true"}},[e._v("#")]),e._v(" 单向数据流")]),e._v(" "),a("ul",[a("li",[e._v("只能从父到子，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。")])]),e._v(" "),a("h2",{attrs:{id:"直接给一个数组项赋值，vue-能检测到变化吗？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接给一个数组项赋值，vue-能检测到变化吗？","aria-hidden":"true"}},[e._v("#")]),e._v(" 直接给一个数组项赋值，Vue 能检测到变化吗？")]),e._v(" "),a("ul",[a("li",[e._v("由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：\n"),a("ul",[a("li",[e._v("当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue")]),e._v(" "),a("li",[e._v("当你修改数组的长度时，例如：vm.items.length = newLength")])])]),e._v(" "),a("li",[e._v("解决")])]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Vue.set")]),e._v("\nVue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" indexOfItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" newValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// vm.$set，Vue.set的一个别名")]),e._v("\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" indexOfItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" newValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Array.prototype.splice")]),e._v("\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("splice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("indexOfItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" newValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Array.prototype.splice")]),e._v("\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("splice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("newLength"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("h2",{attrs:{id:"vue优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue优化","aria-hidden":"true"}},[e._v("#")]),e._v(" vue优化")]),e._v(" "),a("ul",[a("li",[e._v("代码层面的优化\n"),a("ul",[a("li",[e._v("1、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if")]),e._v(" "),a("li",[e._v("2、图片资源懒加载")]),e._v(" "),a("li",[e._v("3、路由懒加载")]),e._v(" "),a("li",[e._v("4、第三方插件的按需引入")]),e._v(" "),a("li",[e._v("5、优化无限列表性能")])])]),e._v(" "),a("li",[e._v("Webpack 层面的优化\n"),a("ul",[a("li",[e._v("1、Webpack 对图片进行压缩")]),e._v(" "),a("li",[e._v("2、减少 ES6 转为 ES5 的冗余代码")]),e._v(" "),a("li",[e._v("3、构建结果输出分析")]),e._v(" "),a("li",[e._v("4、提取公共代码")])])]),e._v(" "),a("li",[e._v("基础的 Web 技术的优化\n"),a("ul",[a("li",[e._v("开启 gzip 压缩")]),e._v(" "),a("li",[e._v("浏览器缓存")]),e._v(" "),a("li",[e._v("CDN的使用")]),e._v(" "),a("li",[e._v("使用 Chrome Performance 查找性能瓶颈")])])])]),e._v(" "),a("h2",{attrs:{id:"vue-首次渲染的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-首次渲染的过程","aria-hidden":"true"}},[e._v("#")]),e._v(" vue 首次渲染的过程")]),e._v(" "),a("ul",[a("li",[e._v("1、new Vue 的时候 传递参数,进行一些初始化的过程")]),e._v(" "),a("li",[e._v("2、执行mount挂载,他会创建一个渲染Watcher,执行回调函数进行页面更新,回调函数里面主要是生成vnode和调用update方法进行页面更新")]),e._v(" "),a("li",[e._v("3、vnode 是通过render函数 去执行createElement 创建一个vnode")]),e._v(" "),a("li",[e._v("4、update方法 执行的实际是patch方法,他是用来把vnode渲染成真是的DOM,接收参数第一个是"),a("code",[e._v("vm.$el")]),e._v("(更新的时候 就是一个vnode),第二个是vnode")]),e._v(" "),a("li",[e._v("5、patch(普通元素)首先会把第一个参数dom 转成成vnode,在通过"),a("code",[e._v("createElm")]),e._v("把虚拟节点创建真实的 DOM 并插入到它的父节点中,里面会递归的调用"),a("code",[e._v("createElm")]),e._v("去创建子组件,在通过insert方法把元素挂载到parent节点上(所以是先执行子节点的insert挂载,在执行parent挂载)")])]),e._v(" "),a("h2",{attrs:{id:"update-组件更新的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update-组件更新的情况","aria-hidden":"true"}},[e._v("#")]),e._v(" update 组件更新的情况")]),e._v(" "),a("ul",[a("li",[e._v("1、update 同样走的patch方法,这次patch 走组件的情况,通过"),a("code",[e._v("createElm")]),e._v("方法创建vnode,这个时候vnode是组件创建的,他会执行组件vnode里面的"),a("code",[e._v("init")]),e._v("钩子,去创建组件实例,同时调用mount方法,进行挂载,回到之前的mount逻辑 创建渲染watcher")]),e._v(" "),a("li",[e._v("2、"),a("code",[e._v("init")]),e._v("完成后会调用 insert完成组件的 DOM 插入")])]),e._v(" "),a("h2",{attrs:{id:"patch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patch","aria-hidden":"true"}},[e._v("#")]),e._v(" patch")]),e._v(" "),a("ul",[a("li",[e._v("他主要第一个参数 上一个节点,第二个是当前的vnode,他的作用是把vnode转换成dom插入到上一个节点上")])]),e._v(" "),a("h2",{attrs:{id:"domdiff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#domdiff","aria-hidden":"true"}},[e._v("#")]),e._v(" DOMDiff")]),e._v(" "),a("ul",[a("li",[e._v("核心的patch方法,接收(新节点,老节点)")]),e._v(" "),a("li",[e._v("1、比较标签,当标签不一样,直接替换")]),e._v(" "),a("li",[e._v("2、标签一样,比较文本,如果内容不一样,用新的替换老的文本节点")]),e._v(" "),a("li",[e._v("3、标签一样,比较属性,遍历新老属性,进行修改")]),e._v(" "),a("li",[e._v("4、比较儿子节点,a、当老的有孩子,新的没有孩子,直接删除老的child。b、当老的没有孩子,新的有孩子,递归遍历新的孩子往老节点添加。c、当都有孩子的时候是最烦,分5中策略\n"),a("ul",[a("li",[e._v("开头插入,从头开始比较(新 a b c d,老 a b c d e的情况下) 先比较新老的第一个始比较,下次比较第二个")]),e._v(" "),a("li",[e._v("结尾插入,从尾巴开始比较(新 a b c d,老 e a b c d的情况下) 先比较新老的最后一个,下次在比较倒数第二个")]),e._v(" "),a("li",[e._v("正序,用新的头和老的尾巴开始比较,(新的 a b c d,老的 d c b a)")]),e._v(" "),a("li",[e._v("倒序,用新的尾巴和老的头开始比较,(新的 a b c d,老的 d a b c )")]),e._v(" "),a("li",[e._v("乱序,顺序不确定的情况,遍历新节点,用新的第一个DOM去老的里面匹配,如不匹配则直接插入到老节点的前面,如匹配则直接一定老节点。新节点遍历完成,在看老节点中还有剩余的(新节点中没有的)直接删除")]),e._v(" "),a("li",[e._v("最后比较完,判断新节点中还有剩余的元素则需要将剩余的插入，如果老节点中还有剩余则需要全部删除")])])]),e._v(" "),a("li",[e._v("注意 循环的是 尽量不要使用索引作为key 可能会导致重新创建当前元素的所有子元素")])]),e._v(" "),a("h2",{attrs:{id:"完整的导航解析流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完整的导航解析流程","aria-hidden":"true"}},[e._v("#")]),e._v(" 完整的导航解析流程")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*\n  导航被触发。\n  在失活的组件里调用离开守卫。(组件内 beforeRouteLeave)\n  调用全局的 beforeEach 守卫。(全局前置守卫 beforeEach )\n  在重用的组件里调用 beforeRouteUpdate 守卫 (组件内的 beforeRouteUpdate, /foo/1 和 /foo/2 之间跳转的时候用到)\n  在路由配置里调用 beforeEnter。(组件内 beforeEnter)\n  解析异步路由组件。(全局router.beforeResolve  在导航被确认之前,所有组件内守卫和异步路由组件被解析之后)\n  在被激活的组件里调用 beforeRouteEnter(在组件渲染前 不能获取this)\n  调用全局的 beforeResolve 守卫 \n  导航被确认。\n  调用全局的 afterEach 钩子。\n  触发 DOM 更新。\n  用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。\n\n\n  路由配置守卫即配置在路由对象中\n\n    组件实力的导航守卫： beforeRouteLeave beforeRouteEnter beforeRouteUpdate\n\n    全局守卫： beforeEach beforeResolve afterEach\n\n    路由配置守卫： beforeEnter\n\n*/")]),e._v("\n")])])])])}],!1,null,null,null);t.default=v.exports}}]);